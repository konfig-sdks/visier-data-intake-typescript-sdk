/* tslint:disable */
/* eslint-disable */
/*
Visier Data Intake APIs

Visier APIs for sending raw or untransformed source data to Visier

The version of the OpenAPI document: 22222222.99201.1200


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { GetProcessingJobsResponse } from '../models';
// @ts-ignore
import { PushDataCancelResponse } from '../models';
// @ts-ignore
import { PushDataCompleteRequest } from '../models';
// @ts-ignore
import { PushDataCompleteResponse } from '../models';
// @ts-ignore
import { PushDataResponse } from '../models';
// @ts-ignore
import { PushDataSourceDefinitionsDTO } from '../models';
// @ts-ignore
import { ReceivingJobStatusResponse } from '../models';
// @ts-ignore
import { StartTransferResponse } from '../models';
// @ts-ignore
import { Status } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * DataIntakeApi - axios parameter creator
 * @export
 */
export const DataIntakeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this API to retrieve a list of statuses for all processing jobs associated with the given receiving job ID.   Processing jobs deal with an individual analytic tenant\'s data load. A processing job is either triggered through  the UI or is one of many processing jobs spawned from a receiving job. When a processing job is triggered as part  of a set from an receiving job, it is associated to the receiving job through a Parent ID.
         * @summary Retrieve processing job statuses by receiving job ID
         * @param {string} receivingJobId The receiving job ID.
         * @param {string} [tenantCode] The tenant code of the tenant you want to retrieve the processing jobs for. Use this if you are only interested in the results for one analytic tenant.
         * @param {number} [limit] The limit of processing jobs to retrieve per page.
         * @param {number} [start] The index to start retrieving results from, also known as offset. The index begins at 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingJobsByParentReceivingJobId: async (receivingJobId: string, tenantCode?: string, limit?: number, start?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'receivingJobId' is not null or undefined
            assertParamExists('getProcessingJobsByParentReceivingJobId', 'receivingJobId', receivingJobId)
            const localVarPath = `/v1/op/jobs/processing-jobs/{receivingJobId}`
                .replace(`{${"receivingJobId"}}`, encodeURIComponent(String(receivingJobId !== undefined ? receivingJobId : `-receivingJobId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apikey", keyParamName: "apiKeyAuth", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication CookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "VisierASIDToken", configuration})
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            if (tenantCode !== undefined) {
                localVarQueryParameter['tenantCode'] = tenantCode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/op/jobs/processing-jobs/{receivingJobId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Prior to transferring data to Visier, you must identify the sources you want to target. Sources store data for  the solution and are used to map data to Visier\'s data model.   Note: To set up sources in your tenant, contact Visier Customer Success.  This API allows you to query the list of available sources, and identify the source schema and required fields.
         * @summary Retrieve a list of sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSources: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/op/data-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apikey", keyParamName: "apiKeyAuth", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication CookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "VisierASIDToken", configuration})
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/op/data-sources',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API allows you to transfer data to Visier in batches of records. Each request includes a batch of records  formatted as a comma separated array with the first row containing the column headers in the request body. Each  subsequent request should also include the first row as a header.   Each request transfers a batch of records to a single source. Transfer sessions may include one or more batches before completion.   Each batch is identified by a sequence number. Sequence numbers help identify any batches  that were delivered incorrectly.   Each batch is limited to the following request size:  - Batch size limit: 10 MB  - Record count limit: 300,000 rows
         * @summary Transfer data to sources via JSON
         * @param {string} transferSessionId The transfer session ID returned after the data transfer session starts.
         * @param {string} body 
         * @param {string} [sourceId] The unique identifier associated with the source you want to transfer data to.
         * @param {number} [sequence] The unique sequence number associated with a batch of records.
         * @param {string} [tenantCode] The code of the tenant you want to transfer data to. For example, WFF_j1r or WFF_j1r~c7o.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushData: async (transferSessionId: string, body: string, sourceId?: string, sequence?: number, tenantCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferSessionId' is not null or undefined
            assertParamExists('pushData', 'transferSessionId', transferSessionId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('pushData', 'body', body)
            const localVarPath = `/v1/op/data-transfer-sessions/{transferSessionId}/add`
                .replace(`{${"transferSessionId"}}`, encodeURIComponent(String(transferSessionId !== undefined ? transferSessionId : `-transferSessionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apikey", keyParamName: "apiKeyAuth", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication CookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "VisierASIDToken", configuration})
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (sequence !== undefined) {
                localVarQueryParameter['sequence'] = sequence;
            }

            if (tenantCode !== undefined) {
                localVarQueryParameter['tenantCode'] = tenantCode;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/op/data-transfer-sessions/{transferSessionId}/add',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API allows you to cancel a transfer session after starting it. If a transfer session is cancelled, all  records within the transfer session do not persist in Visier’s data store.   If you cancel a transfer session, please start a new transfer session and resend the complete data set.   You might cancel a transfer session if:  - A request to send a batch of records failed.  - The original set of records is incomplete.  - An infrastructure error occurs.
         * @summary Cancel a transfer session
         * @param {string} transferSessionId The transfer session ID to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushDataCancel: async (transferSessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferSessionId' is not null or undefined
            assertParamExists('pushDataCancel', 'transferSessionId', transferSessionId)
            const localVarPath = `/v1/op/data-transfer-sessions/{transferSessionId}/cancel`
                .replace(`{${"transferSessionId"}}`, encodeURIComponent(String(transferSessionId !== undefined ? transferSessionId : `-transferSessionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apikey", keyParamName: "apiKeyAuth", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication CookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "VisierASIDToken", configuration})
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/op/data-transfer-sessions/{transferSessionId}/cancel',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API allows you to complete the specified transfer session by triggering a receiving job. A receiving job  validates the transferred data and adds the transferred data to Visier’s data store.   You can set an optional parameter to generate a data version through a processing job immediately after the receiving job completes.
         * @summary Complete a transfer session
         * @param {PushDataCompleteRequest} pushDataCompleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushDataComplete: async (pushDataCompleteRequest: PushDataCompleteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pushDataCompleteRequest' is not null or undefined
            assertParamExists('pushDataComplete', 'pushDataCompleteRequest', pushDataCompleteRequest)
            const localVarPath = `/v1/op/jobs/receiving-jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apikey", keyParamName: "apiKeyAuth", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication CookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "VisierASIDToken", configuration})
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: pushDataCompleteRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/op/jobs/receiving-jobs',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(pushDataCompleteRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After completing a transfer session, you may want to know the status of the receiving job and the associated tenant  receiving jobs. A receiving job validates the transferred data and adds the transferred data to Visier’s data store.   Use this API to retrieve the receiving job status and summary of analytic tenant receiving jobs.
         * @summary Retrieve a receiving job’s status
         * @param {string} receivingJobId The **dataReceivingJobId** provided after a data transfer session completes. See **&#x60;/v1/op/jobs/receiving-jobs&#x60;**.
         * @param {boolean} [jobs] If true, returns the status of receiving jobs spawned by the receiving job specified by receivingJobId.
         * @param {string} [tenantCode] The tenant code of the tenant you want to retrieve the receiving jobs for. Use this if you are only interested in the results for one analytic tenant.
         * @param {number} [start] The index to start retrieving results from, also known as offset. The index begins at 0.
         * @param {number} [limit] The number of job statuses to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivingJobStatus: async (receivingJobId: string, jobs?: boolean, tenantCode?: string, start?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'receivingJobId' is not null or undefined
            assertParamExists('receivingJobStatus', 'receivingJobId', receivingJobId)
            const localVarPath = `/v1/op/jobs/receiving-jobs/{receivingJobId}`
                .replace(`{${"receivingJobId"}}`, encodeURIComponent(String(receivingJobId !== undefined ? receivingJobId : `-receivingJobId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apikey", keyParamName: "apiKeyAuth", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication CookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "VisierASIDToken", configuration})
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            if (jobs !== undefined) {
                localVarQueryParameter['jobs'] = jobs;
            }

            if (tenantCode !== undefined) {
                localVarQueryParameter['tenantCode'] = tenantCode;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/op/jobs/receiving-jobs/{receivingJobId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API to start a new transfer session. A transfer session can include one or more batches of records to be  sent to Visier. Batches of records may be transferred as JSON or file payloads.   Recommended: For optimal performance, please include all batches of records in a single transfer session.
         * @summary Start a transfer session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTransfer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/op/data-transfer-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apikey", keyParamName: "apiKeyAuth", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication CookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "VisierASIDToken", configuration})
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/op/data-transfer-sessions',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API allows you to upload data to Visier as CSV or ZIP files. Each request transfers a single file. If the  data intended for Visier is stored in multiple files, you may compress them into a single ZIP file or make  multiple requests within the same transfer session.   File size limit: 3 GB   Each file is identified by a sequence number. Sequence numbers help identify any batches that were delivered incorrectly.   If you define a specific source in the request, all files within the request will target the declared source. If  a source is not defined, the filenames are matched against the source regex to correctly assign each file to a  source. To find out the source regex, please contact Visier Customer Success.   Note: If you include files that should target multiple sources in one ZIP file, do not define a source in the request.   Analytic tenants: For optimal transfer speed, provide one ZIP file per source.  Administrating tenants: For optimal transfer speed, provide one ZIP file containing all the required data files for your analytic tenants.  In the ZIP file, use one folder per analytic tenant. The ZIP file must adhere to the following file structure:   File1.zip  - Folder1: WFF_tenantCode1     - Filename1.csv     - Filename2.csv  - Folder2: WFF_tenantCode2     - Filename3.csv     - Filename4.csv
         * @summary Transfer data to sources via file upload
         * @param {string} transferSessionId The transfer session ID returned after the data transfer session starts.
         * @param {any} body 
         * @param {string} [sourceId] The unique identifier associated with the source you want to transfer data to.
         * @param {string} [sequence] The unique sequence number associated with a batch of records.
         * @param {string} [tenantCode] The code of the tenant you want to transfer data to. For example, WFF_j1r or WFF_j1r~c7o.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadData: async (transferSessionId: string, body: any, sourceId?: string, sequence?: string, tenantCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferSessionId' is not null or undefined
            assertParamExists('uploadData', 'transferSessionId', transferSessionId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadData', 'body', body)
            const localVarPath = `/v1/op/data-transfer-sessions/{transferSessionId}/upload`
                .replace(`{${"transferSessionId"}}`, encodeURIComponent(String(transferSessionId !== undefined ? transferSessionId : `-transferSessionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apikey", keyParamName: "apiKeyAuth", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            // authentication CookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "VisierASIDToken", configuration})
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            // authentication OAuth2Auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Auth", [], configuration)
            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (sequence !== undefined) {
                localVarQueryParameter['sequence'] = sequence;
            }

            if (tenantCode !== undefined) {
                localVarQueryParameter['tenantCode'] = tenantCode;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/op/data-transfer-sessions/{transferSessionId}/upload',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataIntakeApi - functional programming interface
 * @export
 */
export const DataIntakeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataIntakeApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this API to retrieve a list of statuses for all processing jobs associated with the given receiving job ID.   Processing jobs deal with an individual analytic tenant\'s data load. A processing job is either triggered through  the UI or is one of many processing jobs spawned from a receiving job. When a processing job is triggered as part  of a set from an receiving job, it is associated to the receiving job through a Parent ID.
         * @summary Retrieve processing job statuses by receiving job ID
         * @param {DataIntakeApiGetProcessingJobsByParentReceivingJobIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessingJobsByParentReceivingJobId(requestParameters: DataIntakeApiGetProcessingJobsByParentReceivingJobIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProcessingJobsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessingJobsByParentReceivingJobId(requestParameters.receivingJobId, requestParameters.tenantCode, requestParameters.limit, requestParameters.start, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Prior to transferring data to Visier, you must identify the sources you want to target. Sources store data for  the solution and are used to map data to Visier\'s data model.   Note: To set up sources in your tenant, contact Visier Customer Success.  This API allows you to query the list of available sources, and identify the source schema and required fields.
         * @summary Retrieve a list of sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSources(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushDataSourceDefinitionsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSources(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API allows you to transfer data to Visier in batches of records. Each request includes a batch of records  formatted as a comma separated array with the first row containing the column headers in the request body. Each  subsequent request should also include the first row as a header.   Each request transfers a batch of records to a single source. Transfer sessions may include one or more batches before completion.   Each batch is identified by a sequence number. Sequence numbers help identify any batches  that were delivered incorrectly.   Each batch is limited to the following request size:  - Batch size limit: 10 MB  - Record count limit: 300,000 rows
         * @summary Transfer data to sources via JSON
         * @param {DataIntakeApiPushDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushData(requestParameters: DataIntakeApiPushDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushDataResponse>> {
            const body: string = requestParameters.requestBody;
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushData(requestParameters.transferSessionId, body, requestParameters.sourceId, requestParameters.sequence, requestParameters.tenantCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API allows you to cancel a transfer session after starting it. If a transfer session is cancelled, all  records within the transfer session do not persist in Visier’s data store.   If you cancel a transfer session, please start a new transfer session and resend the complete data set.   You might cancel a transfer session if:  - A request to send a batch of records failed.  - The original set of records is incomplete.  - An infrastructure error occurs.
         * @summary Cancel a transfer session
         * @param {DataIntakeApiPushDataCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushDataCancel(requestParameters: DataIntakeApiPushDataCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushDataCancelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushDataCancel(requestParameters.transferSessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API allows you to complete the specified transfer session by triggering a receiving job. A receiving job  validates the transferred data and adds the transferred data to Visier’s data store.   You can set an optional parameter to generate a data version through a processing job immediately after the receiving job completes.
         * @summary Complete a transfer session
         * @param {DataIntakeApiPushDataCompleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushDataComplete(requestParameters: DataIntakeApiPushDataCompleteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushDataCompleteResponse>> {
            const pushDataCompleteRequest: PushDataCompleteRequest = {
                transferSessionId: requestParameters.transferSessionId,
                processingData: requestParameters.processingData
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushDataComplete(pushDataCompleteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After completing a transfer session, you may want to know the status of the receiving job and the associated tenant  receiving jobs. A receiving job validates the transferred data and adds the transferred data to Visier’s data store.   Use this API to retrieve the receiving job status and summary of analytic tenant receiving jobs.
         * @summary Retrieve a receiving job’s status
         * @param {DataIntakeApiReceivingJobStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receivingJobStatus(requestParameters: DataIntakeApiReceivingJobStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReceivingJobStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receivingJobStatus(requestParameters.receivingJobId, requestParameters.jobs, requestParameters.tenantCode, requestParameters.start, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to start a new transfer session. A transfer session can include one or more batches of records to be  sent to Visier. Batches of records may be transferred as JSON or file payloads.   Recommended: For optimal performance, please include all batches of records in a single transfer session.
         * @summary Start a transfer session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTransfer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startTransfer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API allows you to upload data to Visier as CSV or ZIP files. Each request transfers a single file. If the  data intended for Visier is stored in multiple files, you may compress them into a single ZIP file or make  multiple requests within the same transfer session.   File size limit: 3 GB   Each file is identified by a sequence number. Sequence numbers help identify any batches that were delivered incorrectly.   If you define a specific source in the request, all files within the request will target the declared source. If  a source is not defined, the filenames are matched against the source regex to correctly assign each file to a  source. To find out the source regex, please contact Visier Customer Success.   Note: If you include files that should target multiple sources in one ZIP file, do not define a source in the request.   Analytic tenants: For optimal transfer speed, provide one ZIP file per source.  Administrating tenants: For optimal transfer speed, provide one ZIP file containing all the required data files for your analytic tenants.  In the ZIP file, use one folder per analytic tenant. The ZIP file must adhere to the following file structure:   File1.zip  - Folder1: WFF_tenantCode1     - Filename1.csv     - Filename2.csv  - Folder2: WFF_tenantCode2     - Filename3.csv     - Filename4.csv
         * @summary Transfer data to sources via file upload
         * @param {DataIntakeApiUploadDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadData(requestParameters: DataIntakeApiUploadDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushDataResponse>> {
            const body: any = requestParameters;
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadData(requestParameters.transferSessionId, body, requestParameters.sourceId, requestParameters.sequence, requestParameters.tenantCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataIntakeApi - factory interface
 * @export
 */
export const DataIntakeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataIntakeApiFp(configuration)
    return {
        /**
         * Use this API to retrieve a list of statuses for all processing jobs associated with the given receiving job ID.   Processing jobs deal with an individual analytic tenant\'s data load. A processing job is either triggered through  the UI or is one of many processing jobs spawned from a receiving job. When a processing job is triggered as part  of a set from an receiving job, it is associated to the receiving job through a Parent ID.
         * @summary Retrieve processing job statuses by receiving job ID
         * @param {DataIntakeApiGetProcessingJobsByParentReceivingJobIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingJobsByParentReceivingJobId(requestParameters: DataIntakeApiGetProcessingJobsByParentReceivingJobIdRequest, options?: AxiosRequestConfig): AxiosPromise<GetProcessingJobsResponse> {
            return localVarFp.getProcessingJobsByParentReceivingJobId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Prior to transferring data to Visier, you must identify the sources you want to target. Sources store data for  the solution and are used to map data to Visier\'s data model.   Note: To set up sources in your tenant, contact Visier Customer Success.  This API allows you to query the list of available sources, and identify the source schema and required fields.
         * @summary Retrieve a list of sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSources(options?: AxiosRequestConfig): AxiosPromise<PushDataSourceDefinitionsDTO> {
            return localVarFp.getSources(options).then((request) => request(axios, basePath));
        },
        /**
         * This API allows you to transfer data to Visier in batches of records. Each request includes a batch of records  formatted as a comma separated array with the first row containing the column headers in the request body. Each  subsequent request should also include the first row as a header.   Each request transfers a batch of records to a single source. Transfer sessions may include one or more batches before completion.   Each batch is identified by a sequence number. Sequence numbers help identify any batches  that were delivered incorrectly.   Each batch is limited to the following request size:  - Batch size limit: 10 MB  - Record count limit: 300,000 rows
         * @summary Transfer data to sources via JSON
         * @param {DataIntakeApiPushDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushData(requestParameters: DataIntakeApiPushDataRequest, options?: AxiosRequestConfig): AxiosPromise<PushDataResponse> {
            return localVarFp.pushData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API allows you to cancel a transfer session after starting it. If a transfer session is cancelled, all  records within the transfer session do not persist in Visier’s data store.   If you cancel a transfer session, please start a new transfer session and resend the complete data set.   You might cancel a transfer session if:  - A request to send a batch of records failed.  - The original set of records is incomplete.  - An infrastructure error occurs.
         * @summary Cancel a transfer session
         * @param {DataIntakeApiPushDataCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushDataCancel(requestParameters: DataIntakeApiPushDataCancelRequest, options?: AxiosRequestConfig): AxiosPromise<PushDataCancelResponse> {
            return localVarFp.pushDataCancel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This API allows you to complete the specified transfer session by triggering a receiving job. A receiving job  validates the transferred data and adds the transferred data to Visier’s data store.   You can set an optional parameter to generate a data version through a processing job immediately after the receiving job completes.
         * @summary Complete a transfer session
         * @param {DataIntakeApiPushDataCompleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushDataComplete(requestParameters: DataIntakeApiPushDataCompleteRequest, options?: AxiosRequestConfig): AxiosPromise<PushDataCompleteResponse> {
            return localVarFp.pushDataComplete(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * After completing a transfer session, you may want to know the status of the receiving job and the associated tenant  receiving jobs. A receiving job validates the transferred data and adds the transferred data to Visier’s data store.   Use this API to retrieve the receiving job status and summary of analytic tenant receiving jobs.
         * @summary Retrieve a receiving job’s status
         * @param {DataIntakeApiReceivingJobStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receivingJobStatus(requestParameters: DataIntakeApiReceivingJobStatusRequest, options?: AxiosRequestConfig): AxiosPromise<ReceivingJobStatusResponse> {
            return localVarFp.receivingJobStatus(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to start a new transfer session. A transfer session can include one or more batches of records to be  sent to Visier. Batches of records may be transferred as JSON or file payloads.   Recommended: For optimal performance, please include all batches of records in a single transfer session.
         * @summary Start a transfer session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTransfer(options?: AxiosRequestConfig): AxiosPromise<StartTransferResponse> {
            return localVarFp.startTransfer(options).then((request) => request(axios, basePath));
        },
        /**
         * This API allows you to upload data to Visier as CSV or ZIP files. Each request transfers a single file. If the  data intended for Visier is stored in multiple files, you may compress them into a single ZIP file or make  multiple requests within the same transfer session.   File size limit: 3 GB   Each file is identified by a sequence number. Sequence numbers help identify any batches that were delivered incorrectly.   If you define a specific source in the request, all files within the request will target the declared source. If  a source is not defined, the filenames are matched against the source regex to correctly assign each file to a  source. To find out the source regex, please contact Visier Customer Success.   Note: If you include files that should target multiple sources in one ZIP file, do not define a source in the request.   Analytic tenants: For optimal transfer speed, provide one ZIP file per source.  Administrating tenants: For optimal transfer speed, provide one ZIP file containing all the required data files for your analytic tenants.  In the ZIP file, use one folder per analytic tenant. The ZIP file must adhere to the following file structure:   File1.zip  - Folder1: WFF_tenantCode1     - Filename1.csv     - Filename2.csv  - Folder2: WFF_tenantCode2     - Filename3.csv     - Filename4.csv
         * @summary Transfer data to sources via file upload
         * @param {DataIntakeApiUploadDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadData(requestParameters: DataIntakeApiUploadDataRequest, options?: AxiosRequestConfig): AxiosPromise<PushDataResponse> {
            return localVarFp.uploadData(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProcessingJobsByParentReceivingJobId operation in DataIntakeApi.
 * @export
 * @interface DataIntakeApiGetProcessingJobsByParentReceivingJobIdRequest
 */
export type DataIntakeApiGetProcessingJobsByParentReceivingJobIdRequest = {
    
    /**
    * The receiving job ID.
    * @type {string}
    * @memberof DataIntakeApiGetProcessingJobsByParentReceivingJobId
    */
    readonly receivingJobId: string
    
    /**
    * The tenant code of the tenant you want to retrieve the processing jobs for. Use this if you are only interested in the results for one analytic tenant.
    * @type {string}
    * @memberof DataIntakeApiGetProcessingJobsByParentReceivingJobId
    */
    readonly tenantCode?: string
    
    /**
    * The limit of processing jobs to retrieve per page.
    * @type {number}
    * @memberof DataIntakeApiGetProcessingJobsByParentReceivingJobId
    */
    readonly limit?: number
    
    /**
    * The index to start retrieving results from, also known as offset. The index begins at 0.
    * @type {number}
    * @memberof DataIntakeApiGetProcessingJobsByParentReceivingJobId
    */
    readonly start?: number
    
}

/**
 * Request parameters for pushData operation in DataIntakeApi.
 * @export
 * @interface DataIntakeApiPushDataRequest
 */
export type DataIntakeApiPushDataRequest = {
    /**
    * The transfer session ID returned after the data transfer session starts.
    * @type {string}
    * @memberof DataIntakeApiPushData
    */
    readonly transferSessionId: string
    /**
    * 
    * @type {string}
    * @memberof DataIntakeApiPushData
    */
    readonly requestBody: string
    /**
    * The unique identifier associated with the source you want to transfer data to.
    * @type {string}
    * @memberof DataIntakeApiPushData
    */
    readonly sourceId?: string
    /**
    * The unique sequence number associated with a batch of records.
    * @type {number}
    * @memberof DataIntakeApiPushData
    */
    readonly sequence?: number
    /**
    * The code of the tenant you want to transfer data to. For example, WFF_j1r or WFF_j1r~c7o.
    * @type {string}
    * @memberof DataIntakeApiPushData
    */
    readonly tenantCode?: string
}

/**
 * Request parameters for pushDataCancel operation in DataIntakeApi.
 * @export
 * @interface DataIntakeApiPushDataCancelRequest
 */
export type DataIntakeApiPushDataCancelRequest = {
    
    /**
    * The transfer session ID to cancel.
    * @type {string}
    * @memberof DataIntakeApiPushDataCancel
    */
    readonly transferSessionId: string
    
}

/**
 * Request parameters for pushDataComplete operation in DataIntakeApi.
 * @export
 * @interface DataIntakeApiPushDataCompleteRequest
 */
export type DataIntakeApiPushDataCompleteRequest = {
    
} & PushDataCompleteRequest

/**
 * Request parameters for receivingJobStatus operation in DataIntakeApi.
 * @export
 * @interface DataIntakeApiReceivingJobStatusRequest
 */
export type DataIntakeApiReceivingJobStatusRequest = {
    
    /**
    * The **dataReceivingJobId** provided after a data transfer session completes. See **`/v1/op/jobs/receiving-jobs`**.
    * @type {string}
    * @memberof DataIntakeApiReceivingJobStatus
    */
    readonly receivingJobId: string
    
    /**
    * If true, returns the status of receiving jobs spawned by the receiving job specified by receivingJobId.
    * @type {boolean}
    * @memberof DataIntakeApiReceivingJobStatus
    */
    readonly jobs?: boolean
    
    /**
    * The tenant code of the tenant you want to retrieve the receiving jobs for. Use this if you are only interested in the results for one analytic tenant.
    * @type {string}
    * @memberof DataIntakeApiReceivingJobStatus
    */
    readonly tenantCode?: string
    
    /**
    * The index to start retrieving results from, also known as offset. The index begins at 0.
    * @type {number}
    * @memberof DataIntakeApiReceivingJobStatus
    */
    readonly start?: number
    
    /**
    * The number of job statuses to return per page.
    * @type {number}
    * @memberof DataIntakeApiReceivingJobStatus
    */
    readonly limit?: number
    
}

/**
 * Request parameters for uploadData operation in DataIntakeApi.
 * @export
 * @interface DataIntakeApiUploadDataRequest
 */
export type DataIntakeApiUploadDataRequest = {
    
    /**
    * The transfer session ID returned after the data transfer session starts.
    * @type {string}
    * @memberof DataIntakeApiUploadData
    */
    readonly transferSessionId: string
    
    /**
    * The unique identifier associated with the source you want to transfer data to.
    * @type {string}
    * @memberof DataIntakeApiUploadData
    */
    readonly sourceId?: string
    
    /**
    * The unique sequence number associated with a batch of records.
    * @type {string}
    * @memberof DataIntakeApiUploadData
    */
    readonly sequence?: string
    
    /**
    * The code of the tenant you want to transfer data to. For example, WFF_j1r or WFF_j1r~c7o.
    * @type {string}
    * @memberof DataIntakeApiUploadData
    */
    readonly tenantCode?: string
    
} & any

/**
 * DataIntakeApiGenerated - object-oriented interface
 * @export
 * @class DataIntakeApiGenerated
 * @extends {BaseAPI}
 */
export class DataIntakeApiGenerated extends BaseAPI {
    /**
     * Use this API to retrieve a list of statuses for all processing jobs associated with the given receiving job ID.   Processing jobs deal with an individual analytic tenant\'s data load. A processing job is either triggered through  the UI or is one of many processing jobs spawned from a receiving job. When a processing job is triggered as part  of a set from an receiving job, it is associated to the receiving job through a Parent ID.
     * @summary Retrieve processing job statuses by receiving job ID
     * @param {DataIntakeApiGetProcessingJobsByParentReceivingJobIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataIntakeApiGenerated
     */
    public getProcessingJobsByParentReceivingJobId(requestParameters: DataIntakeApiGetProcessingJobsByParentReceivingJobIdRequest, options?: AxiosRequestConfig) {
        return DataIntakeApiFp(this.configuration).getProcessingJobsByParentReceivingJobId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Prior to transferring data to Visier, you must identify the sources you want to target. Sources store data for  the solution and are used to map data to Visier\'s data model.   Note: To set up sources in your tenant, contact Visier Customer Success.  This API allows you to query the list of available sources, and identify the source schema and required fields.
     * @summary Retrieve a list of sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataIntakeApiGenerated
     */
    public getSources(options?: AxiosRequestConfig) {
        return DataIntakeApiFp(this.configuration).getSources(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API allows you to transfer data to Visier in batches of records. Each request includes a batch of records  formatted as a comma separated array with the first row containing the column headers in the request body. Each  subsequent request should also include the first row as a header.   Each request transfers a batch of records to a single source. Transfer sessions may include one or more batches before completion.   Each batch is identified by a sequence number. Sequence numbers help identify any batches  that were delivered incorrectly.   Each batch is limited to the following request size:  - Batch size limit: 10 MB  - Record count limit: 300,000 rows
     * @summary Transfer data to sources via JSON
     * @param {DataIntakeApiPushDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataIntakeApiGenerated
     */
    public pushData(requestParameters: DataIntakeApiPushDataRequest, options?: AxiosRequestConfig) {
        return DataIntakeApiFp(this.configuration).pushData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API allows you to cancel a transfer session after starting it. If a transfer session is cancelled, all  records within the transfer session do not persist in Visier’s data store.   If you cancel a transfer session, please start a new transfer session and resend the complete data set.   You might cancel a transfer session if:  - A request to send a batch of records failed.  - The original set of records is incomplete.  - An infrastructure error occurs.
     * @summary Cancel a transfer session
     * @param {DataIntakeApiPushDataCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataIntakeApiGenerated
     */
    public pushDataCancel(requestParameters: DataIntakeApiPushDataCancelRequest, options?: AxiosRequestConfig) {
        return DataIntakeApiFp(this.configuration).pushDataCancel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API allows you to complete the specified transfer session by triggering a receiving job. A receiving job  validates the transferred data and adds the transferred data to Visier’s data store.   You can set an optional parameter to generate a data version through a processing job immediately after the receiving job completes.
     * @summary Complete a transfer session
     * @param {DataIntakeApiPushDataCompleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataIntakeApiGenerated
     */
    public pushDataComplete(requestParameters: DataIntakeApiPushDataCompleteRequest, options?: AxiosRequestConfig) {
        return DataIntakeApiFp(this.configuration).pushDataComplete(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After completing a transfer session, you may want to know the status of the receiving job and the associated tenant  receiving jobs. A receiving job validates the transferred data and adds the transferred data to Visier’s data store.   Use this API to retrieve the receiving job status and summary of analytic tenant receiving jobs.
     * @summary Retrieve a receiving job’s status
     * @param {DataIntakeApiReceivingJobStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataIntakeApiGenerated
     */
    public receivingJobStatus(requestParameters: DataIntakeApiReceivingJobStatusRequest, options?: AxiosRequestConfig) {
        return DataIntakeApiFp(this.configuration).receivingJobStatus(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to start a new transfer session. A transfer session can include one or more batches of records to be  sent to Visier. Batches of records may be transferred as JSON or file payloads.   Recommended: For optimal performance, please include all batches of records in a single transfer session.
     * @summary Start a transfer session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataIntakeApiGenerated
     */
    public startTransfer(options?: AxiosRequestConfig) {
        return DataIntakeApiFp(this.configuration).startTransfer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API allows you to upload data to Visier as CSV or ZIP files. Each request transfers a single file. If the  data intended for Visier is stored in multiple files, you may compress them into a single ZIP file or make  multiple requests within the same transfer session.   File size limit: 3 GB   Each file is identified by a sequence number. Sequence numbers help identify any batches that were delivered incorrectly.   If you define a specific source in the request, all files within the request will target the declared source. If  a source is not defined, the filenames are matched against the source regex to correctly assign each file to a  source. To find out the source regex, please contact Visier Customer Success.   Note: If you include files that should target multiple sources in one ZIP file, do not define a source in the request.   Analytic tenants: For optimal transfer speed, provide one ZIP file per source.  Administrating tenants: For optimal transfer speed, provide one ZIP file containing all the required data files for your analytic tenants.  In the ZIP file, use one folder per analytic tenant. The ZIP file must adhere to the following file structure:   File1.zip  - Folder1: WFF_tenantCode1     - Filename1.csv     - Filename2.csv  - Folder2: WFF_tenantCode2     - Filename3.csv     - Filename4.csv
     * @summary Transfer data to sources via file upload
     * @param {DataIntakeApiUploadDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataIntakeApiGenerated
     */
    public uploadData(requestParameters: DataIntakeApiUploadDataRequest, options?: AxiosRequestConfig) {
        return DataIntakeApiFp(this.configuration).uploadData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
